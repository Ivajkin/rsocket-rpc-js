# RSocket JavaScript RPC Protobuf Generator

## Bugs and Feedback

For bugs, questions, and discussions please use the [Github Issues](https://github.com/netifi/rsocket-js-rpc/issues).

## About This Library

RSocket RPC is an abstraction library for any RPC system to work over RSocket.
The RSocket RPC Protobuf generator is a plugin to enable easy creation of RSocket RPC client and server code from a protobuf definition file.

## Using this plugin

Install `rsocket-rpc-protobuf` as a Dev dependency.
In your project's package.json, add a script for `protoc` similar to below:

```
"protoc": "protoc --proto_path=proto --js_out=import_style=commonjs,binary:src --rsocket_rpc_out=src --plugin=protoc-gen-rsocket_rpc=node_modules/.bin/rsocket_rpc_js_protoc_plugin proto/**/*.proto proto/**/**/*.proto"
```
 
In this script, `protoc` is being invoked with arguments:

`proto_path` : this is the base directory where your *.proto files live (`/proto` in this case)

`js_out` : configuration for output style of the generated JavaScript

`rsocket_rpc_out` : the base directory in which to put the generated files (`/src` here)

`plugin` : this directs `protoc` on the actual plugin to use - here we have aliased the rsocket plugin to the artifact in node_modules

And finally, the `search pattern`. In this case I have included `proto/**/*.proto` and `proto/**/**/*.proto` because the pattern is strictly evaluated. My sample project has proto files in single and double nested directories under `/proto`.

### Example

Here is a sample proto file contained in this project:
```angular2html
syntax = "proto3";

package io.netifi.proteus.rpc;

import "google/protobuf/empty.proto";
import "proteus/core.proto";

service SimpleService {
  // Request / Response
  rpc RequestReply (SimpleRequest) returns (SimpleResponse) {}

  // Fire-and-Forget
  rpc FireAndForget (SimpleRequest) returns (google.protobuf.Empty) {
    option (proteus.options) = {
      fire_and_forget: true
    };
  }

  // Single Request / Streaming Response
  rpc RequestStream (SimpleRequest) returns (stream SimpleResponse) {}

  // Streaming Request / Single Response
  rpc StreamingRequestSingleResponse (stream SimpleRequest) returns (SimpleResponse) {}

  // Streaming Request / Streaming Response
  rpc StreamingRequestAndResponse (stream SimpleRequest) returns (stream SimpleResponse) {}
}

message SimpleRequest {
  string requestMessage = 1;
}

message SimpleResponse {
  string responseMessage = 1;
}
```
     
Something to note is that it references `proteus/core.proto`. This is an extension of Google's protobuf definition that we are using to add a "Fire and Forget" interaction type to Protobuf services. The name will likely change in the future, but the functionality will remain.

Two files are created, one which defines all of the Protobuf types and their getters and setters:

#### Types

```angular2html
/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

var google_protobuf_empty_pb = require('google-protobuf/google/protobuf/empty_pb.js');
var proteus_core_pb = require('../../proteus/core_pb.js');
goog.exportSymbol('proto.io.netifi.proteus.rpc.SimpleRequest', null, global);
goog.exportSymbol('proto.io.netifi.proteus.rpc.SimpleResponse', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.netifi.proteus.rpc.SimpleRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.netifi.proteus.rpc.SimpleRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.netifi.proteus.rpc.SimpleRequest.displayName = 'proto.io.netifi.proteus.rpc.SimpleRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.netifi.proteus.rpc.SimpleRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.io.netifi.proteus.rpc.SimpleRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.netifi.proteus.rpc.SimpleRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.netifi.proteus.rpc.SimpleRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    requestmessage: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.netifi.proteus.rpc.SimpleRequest}
 */
proto.io.netifi.proteus.rpc.SimpleRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.netifi.proteus.rpc.SimpleRequest;
  return proto.io.netifi.proteus.rpc.SimpleRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.netifi.proteus.rpc.SimpleRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.netifi.proteus.rpc.SimpleRequest}
 */
proto.io.netifi.proteus.rpc.SimpleRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setRequestmessage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.netifi.proteus.rpc.SimpleRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.netifi.proteus.rpc.SimpleRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.netifi.proteus.rpc.SimpleRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.netifi.proteus.rpc.SimpleRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getRequestmessage();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string requestMessage = 1;
 * @return {string}
 */
proto.io.netifi.proteus.rpc.SimpleRequest.prototype.getRequestmessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.io.netifi.proteus.rpc.SimpleRequest.prototype.setRequestmessage = function(value) {
  jspb.Message.setProto3StringField(this, 1, value);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.io.netifi.proteus.rpc.SimpleResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.io.netifi.proteus.rpc.SimpleResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.io.netifi.proteus.rpc.SimpleResponse.displayName = 'proto.io.netifi.proteus.rpc.SimpleResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.io.netifi.proteus.rpc.SimpleResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.io.netifi.proteus.rpc.SimpleResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.io.netifi.proteus.rpc.SimpleResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.netifi.proteus.rpc.SimpleResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    responsemessage: jspb.Message.getFieldWithDefault(msg, 1, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.io.netifi.proteus.rpc.SimpleResponse}
 */
proto.io.netifi.proteus.rpc.SimpleResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.io.netifi.proteus.rpc.SimpleResponse;
  return proto.io.netifi.proteus.rpc.SimpleResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.io.netifi.proteus.rpc.SimpleResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.io.netifi.proteus.rpc.SimpleResponse}
 */
proto.io.netifi.proteus.rpc.SimpleResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setResponsemessage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.io.netifi.proteus.rpc.SimpleResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.io.netifi.proteus.rpc.SimpleResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.io.netifi.proteus.rpc.SimpleResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.io.netifi.proteus.rpc.SimpleResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getResponsemessage();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string responseMessage = 1;
 * @return {string}
 */
proto.io.netifi.proteus.rpc.SimpleResponse.prototype.getResponsemessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.io.netifi.proteus.rpc.SimpleResponse.prototype.setResponsemessage = function(value) {
  jspb.Message.setProto3StringField(this, 1, value);
};


goog.object.extend(exports, proto.io.netifi.proteus.rpc);

```


And a second file which defines the client and server

#### Client and Server

```angular2html
// GENERATED CODE -- DO NOT EDIT!

'use strict';
var rsocket_rpc_frames = require('rsocket-rpc-frames');
var rsocket_rpc_core = require('rsocket-rpc-core');
var rsocket_rpc_tracing = require('rsocket-rpc-tracing');
var rsocket_flowable = require('rsocket-flowable');
var proteus_testing_simpleservice_pb = require('../../proteus/testing/simpleservice_pb.js');
var google_protobuf_empty_pb = require('google-protobuf/google/protobuf/empty_pb.js');
var proteus_core_pb = require('../../proteus/core_pb.js');

var SimpleServiceClient = function () {
  function SimpleServiceClient(rs, tracer) {
    this._rs = rs;
    this._tracer = tracer;
    this.requestReplyTrace = rsocket_rpc_tracing.traceSingle(tracer, "SimpleService.requestReply", {"rsocket.service": "io.netifi.proteus.rpc.SimpleService"}, {"rsocket.rpc.role": "client"});
    this.fireAndForgetTrace = rsocket_rpc_tracing.traceSingle(tracer, "SimpleService.fireAndForget", {"rsocket.service": "io.netifi.proteus.rpc.SimpleService"}, {"rsocket.rpc.role": "client"});
    this.requestStreamTrace = rsocket_rpc_tracing.trace(tracer, "SimpleService.requestStream", {"rsocket.service": "io.netifi.proteus.rpc.SimpleService"}, {"rsocket.rpc.role": "client"});
    this.streamingRequestSingleResponseTrace = rsocket_rpc_tracing.trace(tracer, "SimpleService.streamingRequestSingleResponse", {"rsocket.service": "io.netifi.proteus.rpc.SimpleService"}, {"rsocket.rpc.role": "client"});
    this.streamingRequestAndResponseTrace = rsocket_rpc_tracing.trace(tracer, "SimpleService.streamingRequestAndResponse", {"rsocket.service": "io.netifi.proteus.rpc.SimpleService"}, {"rsocket.rpc.role": "client"});
  }
  // Request / Response
  SimpleServiceClient.prototype.requestReply = function requestReply(message, metadata) {
    const map = {};
    return this.requestReplyTrace(map)(new rsocket_flowable.Single(subscriber => {
      var dataBuf = Buffer.from(message.serializeBinary());
      var tracingMetadata = rsocket_rpc_tracing.mapToBuffer(map);
      var metadataBuf = rsocket_rpc_frames.encodeMetadata('io.netifi.proteus.rpc.SimpleService', 'RequestReply', tracingMetadata, metadata || Buffer.alloc(0));
        this._rs.requestResponse({
          data: dataBuf,
          metadata: metadataBuf
        }).map(function (payload) {
          //TODO: resolve either 'https://github.com/rsocket/rsocket-js/issues/19' or 'https://github.com/google/protobuf/issues/1319'
          var binary = payload.data.constructor === Buffer || payload.data.constructor === Uint8Array ? payload.data : new Uint8Array(payload.data);
          return proteus_testing_simpleservice_pb.SimpleResponse.deserializeBinary(binary);
        }).subscribe(subscriber);
      })
    );
  };
  // Fire-and-Forget
  SimpleServiceClient.prototype.fireAndForget = function fireAndForget(message, metadata) {
    const map = {};
    this.fireAndForgetTrace(map)(new rsocket_flowable.Single(function (subscriber) {
      subscriber.onSubscribe();
      subscriber.onComplete();
    })).subscribe({ onSubscribe: function onSubscribe() {}, onComplete: function onComplete() {} });
    var dataBuf = Buffer.from(message.serializeBinary());
    var tracingMetadata = rsocket_rpc_tracing.mapToBuffer(map);
    var metadataBuf = rsocket_rpc_frames.encodeMetadata('io.netifi.proteus.rpc.SimpleService', 'FireAndForget', tracingMetadata, metadata || Buffer.alloc(0));
    this._rs.fireAndForget({
      data: dataBuf,
      metadata: metadataBuf
    });
  };
  // Single Request / Streaming Response
  SimpleServiceClient.prototype.requestStream = function requestStream(message, metadata) {
    const map = {};
    return this.requestStreamTrace(map)(new rsocket_flowable.Flowable(subscriber => {
      var dataBuf = Buffer.from(message.serializeBinary());
      var tracingMetadata = rsocket_rpc_tracing.mapToBuffer(map);
      var metadataBuf = rsocket_rpc_frames.encodeMetadata('io.netifi.proteus.rpc.SimpleService', 'RequestStream', tracingMetadata, metadata || Buffer.alloc(0));
        this._rs.requestStream({
          data: dataBuf,
          metadata: metadataBuf
        }).map(function (payload) {
          //TODO: resolve either 'https://github.com/rsocket/rsocket-js/issues/19' or 'https://github.com/google/protobuf/issues/1319'
          var binary = payload.data.constructor === Buffer || payload.data.constructor === Uint8Array ? payload.data : new Uint8Array(payload.data);
          return proteus_testing_simpleservice_pb.SimpleResponse.deserializeBinary(binary);
        }).subscribe(subscriber);
      })
    );
  };
  // Streaming Request / Single Response
  SimpleServiceClient.prototype.streamingRequestSingleResponse = function streamingRequestSingleResponse(messages, metadata) {
    const map = {};
    return this.streamingRequestSingleResponseTrace(map)(new rsocket_flowable.Flowable(subscriber => {
      var dataBuf;
      var tracingMetadata = rsocket_rpc_tracing.mapToBuffer(map);
      var metadataBuf ;
        this._rs.requestChannel(messages.map(function (message) {
          dataBuf = Buffer.from(message.serializeBinary());
          metadataBuf = rsocket_rpc_frames.encodeMetadata('io.netifi.proteus.rpc.SimpleService', 'StreamingRequestSingleResponse', tracingMetadata, metadata || Buffer.alloc(0));
          return {
            data: dataBuf,
            metadata: metadataBuf
          };
        })).map(function (payload) {
          //TODO: resolve either 'https://github.com/rsocket/rsocket-js/issues/19' or 'https://github.com/google/protobuf/issues/1319'
          var binary = payload.data.constructor === Buffer || payload.data.constructor === Uint8Array ? payload.data : new Uint8Array(payload.data);
          return proteus_testing_simpleservice_pb.SimpleResponse.deserializeBinary(binary);
        }).subscribe(subscriber);
      })
    );
  };
  // Streaming Request / Streaming Response
  SimpleServiceClient.prototype.streamingRequestAndResponse = function streamingRequestAndResponse(messages, metadata) {
    const map = {};
    return this.streamingRequestAndResponseTrace(map)(new rsocket_flowable.Flowable(subscriber => {
      var dataBuf;
      var tracingMetadata = rsocket_rpc_tracing.mapToBuffer(map);
      var metadataBuf ;
        this._rs.requestChannel(messages.map(function (message) {
          dataBuf = Buffer.from(message.serializeBinary());
          metadataBuf = rsocket_rpc_frames.encodeMetadata('io.netifi.proteus.rpc.SimpleService', 'StreamingRequestAndResponse', tracingMetadata, metadata || Buffer.alloc(0));
          return {
            data: dataBuf,
            metadata: metadataBuf
          };
        })).map(function (payload) {
          //TODO: resolve either 'https://github.com/rsocket/rsocket-js/issues/19' or 'https://github.com/google/protobuf/issues/1319'
          var binary = payload.data.constructor === Buffer || payload.data.constructor === Uint8Array ? payload.data : new Uint8Array(payload.data);
          return proteus_testing_simpleservice_pb.SimpleResponse.deserializeBinary(binary);
        }).subscribe(subscriber);
      })
    );
  };
  return SimpleServiceClient;
}();

exports.SimpleServiceClient = SimpleServiceClient;

var SimpleServiceServer = function () {
  function SimpleServiceServer(service, tracer) {
    this._service = service;
    this._tracer = tracer;
    this.requestReplyTrace = rsocket_rpc_tracing.traceSingleAsChild(tracer, "SimpleService.requestReply", {"rsocket.service": "io.netifi.proteus.rpc.SimpleService"}, {"rsocket.rpc.role": "server"});
    this.fireAndForgetTrace = rsocket_rpc_tracing.traceSingleAsChild(tracer, "SimpleService.fireAndForget", {"rsocket.service": "io.netifi.proteus.rpc.SimpleService"}, {"rsocket.rpc.role": "server"});
    this.requestStreamTrace = rsocket_rpc_tracing.traceAsChild(tracer, "SimpleService.requestStream", {"rsocket.service": "io.netifi.proteus.rpc.SimpleService"}, {"rsocket.rpc.role": "server"});
    this.streamingRequestSingleResponseTrace = rsocket_rpc_tracing.traceAsChild(tracer, "SimpleService.streamingRequestSingleResponse", {"rsocket.service": "io.netifi.proteus.rpc.SimpleService"}, {"rsocket.rpc.role": "server"});
    this.streamingRequestAndResponseTrace = rsocket_rpc_tracing.traceAsChild(tracer, "SimpleService.streamingRequestAndResponse", {"rsocket.service": "io.netifi.proteus.rpc.SimpleService"}, {"rsocket.rpc.role": "server"});
    this._channelSwitch = (payload, restOfMessages) => {
      if (payload.metadata == null) {
        return rsocket_flowable.Flowable.error(new Error('metadata is empty'));
      }
      var method = rsocket_rpc_frames.getMethod(payload.metadata);
      var spanContext = rsocket_rpc_tracing.deserializeTraceData(this._tracer, payload.metadata);
      let deserializedMessages;
      switch(method){
        case 'StreamingRequestSingleResponse':
          deserializedMessages = restOfMessages.map(message => proteus_testing_simpleservice_pb.SimpleRequest.deserializeBinary(message));
          return this.streamingRequestSingleResponseTrace(spanContext)(
            this._service
              .streamingRequestSingleResponse(deserializedMessages, payload.metadata)
              .map(function (message) {
                return {
                  data: Buffer.from(message.serializeBinary()),
                  metadata: Buffer.alloc(0)
                }
              })
            );
        case 'StreamingRequestAndResponse':
          deserializedMessages = restOfMessages.map(message => proteus_testing_simpleservice_pb.SimpleRequest.deserializeBinary(message));
          return this.streamingRequestAndResponseTrace(spanContext)(
            this._service
              .streamingRequestAndResponse(deserializedMessages, payload.metadata)
              .map(function (message) {
                return {
                  data: Buffer.from(message.serializeBinary()),
                  metadata: Buffer.alloc(0)
                }
              })
            );
        default:
          return rsocket_flowable.Flowable.error(new Error('unknown method'));
      }
    };
  }
  SimpleServiceServer.prototype.fireAndForget = function fireAndForget(payload) {
    if (payload.metadata == null) {
      throw new Error('metadata is empty');
    }
    var method = rsocket_rpc_frames.getMethod(payload.metadata);
    var spanContext = rsocket_rpc_tracing.deserializeTraceData(this._tracer, payload.metadata);
    switch (method) {
      case 'FireAndForget':
        this.fireAndForgetTrace(spanContext)(new rsocket_flowable.Single(function (subscriber) {
          subscriber.onSubscribe();
          subscriber.onComplete();
          })).subscribe({ onSubscribe: function onSubscribe() {}, onComplete: function onComplete() {} });
        this._service.fireAndForget(proteus_testing_simpleservice_pb.SimpleRequest.deserializeBinary(payload.data), payload.metadata)
        break;
      default:
        throw new Error('unknown method');
    }
  };
  SimpleServiceServer.prototype.requestResponse = function requestResponse(payload) {
    try {
      if (payload.metadata == null) {
        return rsocket_flowable.Single.error(new Error('metadata is empty'));
      }
      var method = rsocket_rpc_frames.getMethod(payload.metadata);
      var spanContext = rsocket_rpc_tracing.deserializeTraceData(this._tracer, payload.metadata);
      switch (method) {
        case 'RequestReply':
          return this.requestReplyTrace(spanContext)(
            this._service
            .requestReply(proteus_testing_simpleservice_pb.SimpleRequest.deserializeBinary(payload.data), payload.metadata)
            .map(function (message) {
              return {
                data: Buffer.from(message.serializeBinary()),
                metadata: Buffer.alloc(0)
              }
            })
          );
        default:
          return rsocket_flowable.Single.error(new Error('unknown method'));
      }
    } catch (error) {
      return rsocket_flowable.Single.error(error);
    }
  };
  SimpleServiceServer.prototype.requestStream = function requestStream(payload) {
    try {
      if (payload.metadata == null) {
        return rsocket_flowable.Flowable.error(new Error('metadata is empty'));
      }
      var method = rsocket_rpc_frames.getMethod(payload.metadata);
      var spanContext = rsocket_rpc_tracing.deserializeTraceData(this._tracer, payload.metadata);
      switch (method) {
        case 'RequestStream':
          return this.requestStreamTrace(spanContext)(
            this._service
              .requestStream(proteus_testing_simpleservice_pb.SimpleRequest.deserializeBinary(payload.data), payload.metadata)
              .map(function (message) {
                return {
                  data: Buffer.from(message.serializeBinary()),
                  metadata: Buffer.alloc(0)
                }
              })
            );
        default:
          return rsocket_flowable.Flowable.error(new Error('unknown method'));
      }
    } catch (error) {
      return rsocket_flowable.Flowable.error(error);
    }
  };
  SimpleServiceServer.prototype.requestChannel = function requestChannel(payloads) {
    let once = false;
    return new rsocket_flowable.Flowable(subscriber => {
      const payloadProxy = new rsocket_rpc_core.QueuingFlowableProcessor();
      payloads.subscribe({
        onNext: payload => {
          if(!once){
            once = true;
            try{
              let result = this._channelSwitch(payload, payloadProxy);
              result.subscribe(subscriber);
            } catch (error){
              subscriber.onError(error);
            }
          }
          payloadProxy.onNext(payload.data);
        },
        onError: error => {
          payloadProxy.onError(error);
        },
        onComplete: () => {
          payloadProxy.onComplete();
        },
        onSubscribe: subscription => {
          payloadProxy.onSubscribe(subscription);
        }
        });
      });
    };
    SimpleServiceServer.prototype.metadataPush = function metadataPush(payload) {
      return rsocket_flowable.Single.error(new Error('metadataPush() is not implemented'));
    };
    return SimpleServiceServer;
  }();

  exports.SimpleServiceServer = SimpleServiceServer;
```

The generated Client takes a ReactiveSocket and an optional Open Tracing Tracer implementation and exposes the methods on the client object directly.

The generated Server also takes an optional Open Tracing Tracer and a `SimpleService` implementation of the defined methods:

`requestReply(request: SimpleRequest) : Single<SimpleResponse>`

`fireAndForget (request: SimpleRequest) : void` - this is the special case that is enabled by our Protobuf extension 
    
`requestStream (request: SimpleRequest) : Flowable<SimpleResponse>`

`streamingRequestSingleResponse (requests: Flowable<SimpleRequest>) : Flowable<SimpleResponse>` - The expectation is that this Flowable will emit once and then complete

`streamingRequestAndResponse (requests: SimpleRequest) : Flowable<SimpleResponse>`

The generated server can be attached to an RSocket and handle traffic which it will decode, unwrap, and dispatch to the appropriate method on the `SimpleService` implementation. All calls will be run through the Tracer, if provided.



## License
Copyright 2017 Netifi Inc.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.